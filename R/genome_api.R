# NCBI Datasets API
#
# NCBI service to query and download biological sequence data across all domains of life from NCBI databases.
#
# The version of the OpenAPI document: v1alpha
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Genome operations
#' @description ncbi.datasets.Genome
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ AssemblyDescriptorsByAccessions } \emph{ Get genome metadata by accession }
#' Get detailed metadata for assembled genomes by accession in a JSON output format.
#'
#' \itemize{
#' \item \emph{ @param } accessions list( character )
#' \item \emph{ @param } limit character
#' \item \emph{ @param } filters.refseq.only character
#' \item \emph{ @param } returned.content Enum < [COMPLETE, ASSM_ACC] > 
#' \item \emph{ @returnType } \link{V1alpha1AssemblyMetadata} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1AssemblyMetadata 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | An unexpected error response.
#'
#' \item return type : GatewayruntimeError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ AssemblyDescriptorsByTaxon } \emph{ Get genome metadata by taxonomic identifier }
#' Get detailed metadata on all assembled genomes for a specified NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#'
#' \itemize{
#' \item \emph{ @param } taxon character
#' \item \emph{ @param } limit character
#' \item \emph{ @param } filters.refseq.only character
#' \item \emph{ @param } tax.exact.match character
#' \item \emph{ @param } returned.content Enum < [COMPLETE, ASSM_ACC] > 
#' \item \emph{ @returnType } \link{V1alpha1AssemblyMetadata} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1AssemblyMetadata 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | An unexpected error response.
#'
#' \item return type : GatewayruntimeError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CheckAssemblyAvailability } \emph{ Check the validity of genome accessions }
#' The &#39;GET&#39; version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
#'
#' \itemize{
#' \item \emph{ @param } accessions list( character )
#' \item \emph{ @param } include.tsv character
#' \item \emph{ @returnType } \link{V1alpha1AssemblyDatasetAvailability} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1AssemblyDatasetAvailability 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CheckAssemblyAvailabilityPost } \emph{ Check the validity of many genome accessions in a single request }
#' The &#39;GET&#39; version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
#'
#' \itemize{
#' \item \emph{ @param } body \link{V1alpha1AssemblyDatasetRequest}
#' \item \emph{ @returnType } \link{V1alpha1AssemblyDatasetAvailability} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1AssemblyDatasetAvailability 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DownloadAssemblyPackage } \emph{ Get a genome dataset by accession }
#' Download a genome dataset including fasta sequence, annotation and a detailed data report by accession.
#'
#' \itemize{
#' \item \emph{ @param } accessions list( character )
#' \item \emph{ @param } chromosomes list( character )
#' \item \emph{ @param } exclude.sequence character
#' \item \emph{ @param } include.annotation.type Enum < [GENOME_GFF, GENOME_GBFF, RNA_FASTA, PROT_FASTA, GENOME_GTF] > 
#' \item \emph{ @param } hydrated Enum < [FULLY_HYDRATED, DATA_REPORT_ONLY] > 
#' \item \emph{ @param } filename character
#'
#'
#' \item status code : 200 | Download selected genome assemblies and associated annotation data as a zip file.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DownloadAssemblyPackagePost } \emph{ Get a genome dataset by post }
#' The &#39;GET&#39; version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
#'
#' \itemize{
#' \item \emph{ @param } body \link{V1alpha1AssemblyDatasetRequest}
#' \item \emph{ @param } filename character
#'
#'
#' \item status code : 200 | Download selected genome assemblies and associated annotation data as a zip file.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenomeDownloadSummary } \emph{ Preview genome dataset download }
#' Get a download summary by accession in a JSON output format.
#'
#' \itemize{
#' \item \emph{ @param } accessions list( character )
#' \item \emph{ @param } chromosomes list( character )
#' \item \emph{ @param } exclude.sequence character
#' \item \emph{ @param } include.annotation.type Enum < [GENOME_GFF, GENOME_GBFF, RNA_FASTA, PROT_FASTA, GENOME_GTF] > 
#' \item \emph{ @param } hydrated Enum < [FULLY_HYDRATED, DATA_REPORT_ONLY] > 
#' \item \emph{ @param } include.tsv character
#' \item \emph{ @returnType } \link{V1alpha1DownloadSummary} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1DownloadSummary 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | An unexpected error response.
#'
#' \item return type : GatewayruntimeError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenomeDownloadSummaryByPost } \emph{ Preview genome dataset download by POST }
#' The &#39;GET&#39; version of download summary is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
#'
#' \itemize{
#' \item \emph{ @param } body \link{V1alpha1AssemblyDatasetRequest}
#' \item \emph{ @returnType } \link{V1alpha1DownloadSummary} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1DownloadSummary 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | An unexpected error response.
#'
#' \item return type : GatewayruntimeError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenomeTaxNameQuery } \emph{ Get a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name. }
#' This endpoint retrieves a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name of any rank.
#'
#' \itemize{
#' \item \emph{ @param } taxon.query character
#' \item \emph{ @returnType } \link{V1alpha1SciNameAndIds} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1SciNameAndIds 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | An unexpected error response.
#'
#' \item return type : GatewayruntimeError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenomeTaxTree } \emph{ Get a taxonomic subtree by taxonomic identifier }
#' Using a NCBI Taxonomy ID or name (common or scientific) at any rank, get a subtree filtered for species with assembled genomes
#'
#' \itemize{
#' \item \emph{ @param } taxon character
#' \item \emph{ @returnType } \link{V1alpha1Organism} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : V1alpha1Organism 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | An unexpected error response.
#'
#' \item return type : GatewayruntimeError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  AssemblyDescriptorsByAccessions  ####################
#'
#' library(ncbi.datasets)
#' var.accessions <- ['accessions_example'] # array[character] | 
#' var.limit <- 'limit_example' # character | Limit the number of returned results (\"all\", \"none\", otherwise an integer value).
#' var.filters.refseq.only <- 'filters.refseq.only_example' # character | If true, only return RefSeq (GCF_) assemblies.
#' var.returned.content <- 'COMPLETE' # character | 
#'
#' #Get genome metadata by accession
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$AssemblyDescriptorsByAccessions(var.accessions, limit=var.limit, filters.refseq.only=var.filters.refseq.only, returned.content=var.returned.content)
#'
#'
#' ####################  AssemblyDescriptorsByTaxon  ####################
#'
#' library(ncbi.datasets)
#' var.taxon <- 'taxon_example' # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#' var.limit <- 'limit_example' # character | Limit the number of returned results (\"all\", \"none\", otherwise an integer value).
#' var.filters.refseq.only <- 'filters.refseq.only_example' # character | If true, only return RefSeq (GCF_) assemblies.
#' var.tax.exact.match <- 'tax.exact.match_example' # character | If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. Ignored for assembly_accession request.
#' var.returned.content <- 'COMPLETE' # character | 
#'
#' #Get genome metadata by taxonomic identifier
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$AssemblyDescriptorsByTaxon(var.taxon, limit=var.limit, filters.refseq.only=var.filters.refseq.only, tax.exact.match=var.tax.exact.match, returned.content=var.returned.content)
#'
#'
#' ####################  CheckAssemblyAvailability  ####################
#'
#' library(ncbi.datasets)
#' var.accessions <- ['accessions_example'] # array[character] | NCBI genome assembly accessions
#' var.include.tsv <- 'include.tsv_example' # character | 
#'
#' #Check the validity of genome accessions
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$CheckAssemblyAvailability(var.accessions, include.tsv=var.include.tsv)
#'
#'
#' ####################  CheckAssemblyAvailabilityPost  ####################
#'
#' library(ncbi.datasets)
#' var.body <- V1alpha1AssemblyDatasetRequest$new() # V1alpha1AssemblyDatasetRequest | 
#'
#' #Check the validity of many genome accessions in a single request
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$CheckAssemblyAvailabilityPost(var.body)
#'
#'
#' ####################  DownloadAssemblyPackage  ####################
#'
#' library(ncbi.datasets)
#' var.accessions <- ['accessions_example'] # array[character] | NCBI genome assembly accessions
#' var.chromosomes <- ['chromosomes_example'] # array[character] | The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
#' var.exclude.sequence <- 'exclude.sequence_example' # character | Set to true to omit the genomic sequence.
#' var.include.annotation.type <- ['include.annotation.type_example'] # array[character] | Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
#' var.hydrated <- 'FULLY_HYDRATED' # character | 
#' var.filename <- 'ncbi_dataset.zip' # character | Output file name.
#'
#' #Get a genome dataset by accession
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$DownloadAssemblyPackage(var.accessions, chromosomes=var.chromosomes, exclude.sequence=var.exclude.sequence, include.annotation.type=var.include.annotation.type, hydrated=var.hydrated, filename=var.filename)
#'
#'
#' ####################  DownloadAssemblyPackagePost  ####################
#'
#' library(ncbi.datasets)
#' var.body <- V1alpha1AssemblyDatasetRequest$new() # V1alpha1AssemblyDatasetRequest | 
#' var.filename <- 'ncbi_dataset.zip' # character | Output file name.
#'
#' #Get a genome dataset by post
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$DownloadAssemblyPackagePost(var.body, filename=var.filename)
#'
#'
#' ####################  GenomeDownloadSummary  ####################
#'
#' library(ncbi.datasets)
#' var.accessions <- ['accessions_example'] # array[character] | NCBI genome assembly accessions
#' var.chromosomes <- ['chromosomes_example'] # array[character] | The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
#' var.exclude.sequence <- 'exclude.sequence_example' # character | Set to true to omit the genomic sequence.
#' var.include.annotation.type <- ['include.annotation.type_example'] # array[character] | Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
#' var.hydrated <- 'FULLY_HYDRATED' # character | 
#' var.include.tsv <- 'include.tsv_example' # character | 
#'
#' #Preview genome dataset download
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$GenomeDownloadSummary(var.accessions, chromosomes=var.chromosomes, exclude.sequence=var.exclude.sequence, include.annotation.type=var.include.annotation.type, hydrated=var.hydrated, include.tsv=var.include.tsv)
#'
#'
#' ####################  GenomeDownloadSummaryByPost  ####################
#'
#' library(ncbi.datasets)
#' var.body <- V1alpha1AssemblyDatasetRequest$new() # V1alpha1AssemblyDatasetRequest | 
#'
#' #Preview genome dataset download by POST
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$GenomeDownloadSummaryByPost(var.body)
#'
#'
#' ####################  GenomeTaxNameQuery  ####################
#'
#' library(ncbi.datasets)
#' var.taxon.query <- 'taxon.query_example' # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#'
#' #Get a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name.
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$GenomeTaxNameQuery(var.taxon.query)
#'
#'
#' ####################  GenomeTaxTree  ####################
#'
#' library(ncbi.datasets)
#' var.taxon <- 'taxon_example' # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#'
#' #Get a taxonomic subtree by taxonomic identifier
#' api.instance <- GenomeApi$new()
#'
#' result <- api.instance$GenomeTaxTree(var.taxon)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom caTools base64encode
#' @export
GenomeApi <- R6::R6Class(
  'GenomeApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    AssemblyDescriptorsByAccessions = function(accessions, limit=NULL, filters.refseq.only=NULL, returned.content='COMPLETE', ...){
      apiResponse <- self$AssemblyDescriptorsByAccessionsWithHttpInfo(accessions, limit, filters.refseq.only, returned.content, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    AssemblyDescriptorsByAccessionsWithHttpInfo = function(accessions, limit=NULL, filters.refseq.only=NULL, returned.content='COMPLETE', ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }

      queryParams['limit'] <- limit

      queryParams['filters.refseq_only'] <- filters.refseq.only

      queryParams['returned_content'] <- returned.content

      urlPath <- "/genome/accession/{accessions}"
      if (!missing(`accessions`)) {
        urlPath <- gsub(paste0("\\{", "accessions", "\\}"), URLencode(as.character(`accessions`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1AssemblyMetadata", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    AssemblyDescriptorsByTaxon = function(taxon, limit=NULL, filters.refseq.only=NULL, tax.exact.match=NULL, returned.content='COMPLETE', ...){
      apiResponse <- self$AssemblyDescriptorsByTaxonWithHttpInfo(taxon, limit, filters.refseq.only, tax.exact.match, returned.content, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    AssemblyDescriptorsByTaxonWithHttpInfo = function(taxon, limit=NULL, filters.refseq.only=NULL, tax.exact.match=NULL, returned.content='COMPLETE', ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }

      queryParams['limit'] <- limit

      queryParams['filters.refseq_only'] <- filters.refseq.only

      queryParams['tax_exact_match'] <- tax.exact.match

      queryParams['returned_content'] <- returned.content

      urlPath <- "/genome/taxon/{taxon}"
      if (!missing(`taxon`)) {
        urlPath <- gsub(paste0("\\{", "taxon", "\\}"), URLencode(as.character(`taxon`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1AssemblyMetadata", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CheckAssemblyAvailability = function(accessions, include.tsv=NULL, ...){
      apiResponse <- self$CheckAssemblyAvailabilityWithHttpInfo(accessions, include.tsv, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CheckAssemblyAvailabilityWithHttpInfo = function(accessions, include.tsv=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }

      queryParams['include_tsv'] <- include.tsv

      urlPath <- "/genome/accession/{accessions}/check"
      if (!missing(`accessions`)) {
        urlPath <- gsub(paste0("\\{", "accessions", "\\}"), URLencode(as.character(`accessions`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1AssemblyDatasetAvailability", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CheckAssemblyAvailabilityPost = function(body, ...){
      apiResponse <- self$CheckAssemblyAvailabilityPostWithHttpInfo(body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CheckAssemblyAvailabilityPostWithHttpInfo = function(body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`body`)) {
        stop("Missing required parameter `body`.")
      }

      if (!missing(`body`)) {
        body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/genome/check"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1AssemblyDatasetAvailability", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DownloadAssemblyPackage = function(accessions, chromosomes=NULL, exclude.sequence=NULL, include.annotation.type=NULL, hydrated='FULLY_HYDRATED', filename='ncbi_dataset.zip', ...){
      apiResponse <- self$DownloadAssemblyPackageWithHttpInfo(accessions, chromosomes, exclude.sequence, include.annotation.type, hydrated, filename, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DownloadAssemblyPackageWithHttpInfo = function(accessions, chromosomes=NULL, exclude.sequence=NULL, include.annotation.type=NULL, hydrated='FULLY_HYDRATED', filename='ncbi_dataset.zip', ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }

      queryParams['chromosomes'] <- chromosomes

      queryParams['exclude_sequence'] <- exclude.sequence

      queryParams['include_annotation_type'] <- include.annotation.type

      queryParams['hydrated'] <- hydrated

      queryParams['filename'] <- filename

      urlPath <- "/genome/accession/{accessions}/download"
      if (!missing(`accessions`)) {
        urlPath <- gsub(paste0("\\{", "accessions", "\\}"), URLencode(as.character(`accessions`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DownloadAssemblyPackagePost = function(body, filename='ncbi_dataset.zip', ...){
      apiResponse <- self$DownloadAssemblyPackagePostWithHttpInfo(body, filename, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DownloadAssemblyPackagePostWithHttpInfo = function(body, filename='ncbi_dataset.zip', ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`body`)) {
        stop("Missing required parameter `body`.")
      }

      queryParams['filename'] <- filename

      if (!missing(`body`)) {
        body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/genome/download"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenomeDownloadSummary = function(accessions, chromosomes=NULL, exclude.sequence=NULL, include.annotation.type=NULL, hydrated='FULLY_HYDRATED', include.tsv=NULL, ...){
      apiResponse <- self$GenomeDownloadSummaryWithHttpInfo(accessions, chromosomes, exclude.sequence, include.annotation.type, hydrated, include.tsv, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenomeDownloadSummaryWithHttpInfo = function(accessions, chromosomes=NULL, exclude.sequence=NULL, include.annotation.type=NULL, hydrated='FULLY_HYDRATED', include.tsv=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }

      queryParams['chromosomes'] <- chromosomes

      queryParams['exclude_sequence'] <- exclude.sequence

      queryParams['include_annotation_type'] <- include.annotation.type

      queryParams['hydrated'] <- hydrated

      queryParams['include_tsv'] <- include.tsv

      urlPath <- "/genome/accession/{accessions}/download_summary"
      if (!missing(`accessions`)) {
        urlPath <- gsub(paste0("\\{", "accessions", "\\}"), URLencode(as.character(`accessions`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1DownloadSummary", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenomeDownloadSummaryByPost = function(body, ...){
      apiResponse <- self$GenomeDownloadSummaryByPostWithHttpInfo(body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenomeDownloadSummaryByPostWithHttpInfo = function(body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`body`)) {
        stop("Missing required parameter `body`.")
      }

      if (!missing(`body`)) {
        body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/genome/download_summary"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1DownloadSummary", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenomeTaxNameQuery = function(taxon.query, ...){
      apiResponse <- self$GenomeTaxNameQueryWithHttpInfo(taxon.query, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenomeTaxNameQueryWithHttpInfo = function(taxon.query, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`taxon.query`)) {
        stop("Missing required parameter `taxon.query`.")
      }

      urlPath <- "/genome/taxon_suggest/{taxon_query}"
      if (!missing(`taxon.query`)) {
        urlPath <- gsub(paste0("\\{", "taxon_query", "\\}"), URLencode(as.character(`taxon.query`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1SciNameAndIds", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenomeTaxTree = function(taxon, ...){
      apiResponse <- self$GenomeTaxTreeWithHttpInfo(taxon, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenomeTaxTreeWithHttpInfo = function(taxon, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }

      urlPath <- "/genome/taxon/{taxon}/tree"
      if (!missing(`taxon`)) {
        urlPath <- gsub(paste0("\\{", "taxon", "\\}"), URLencode(as.character(`taxon`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "V1alpha1Organism", loadNamespace("ncbi.datasets")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
